from __future__ import annotations

from typing import TYPE_CHECKING

from PIL import Image

from schemas.ocr_models import PageLayout, TextLine
from utils.logger import get_logger

if TYPE_CHECKING:
    from surya.detection import DetectionPredictor
    from surya.recognition import RecognitionPredictor

logger = get_logger("Extractor")


def load_recognition_predictor():
    """Instantiate and return the Surya RecognitionPredictor."""
    from surya.foundation import FoundationPredictor
    from surya.recognition import RecognitionPredictor

    logger.info("Loading RecognitionPredictor (~1.8GB model)... ⏳")
    foundation = FoundationPredictor()
    rec_predictor = RecognitionPredictor(foundation)
    logger.info("RecognitionPredictor loaded. ✅")
    return rec_predictor


def extract_text_from_layout(
    image: Image.Image,
    layout: PageLayout,
    rec_predictor: RecognitionPredictor,
    det_predictor: DetectionPredictor,
) -> PageLayout:
    """Take a pre-computed PageLayout and use Surya to extract actual characters.

    Args:
        image: The source high-res PIL Image.
        layout: The Pydantic PageLayout generated by `layout_parser.py`.
        rec_predictor: The instantiated Surya RecognitionPredictor.
        det_predictor: The instantiated Surya DetectionPredictor (required by RecognitionPredictor).

    Returns:
        PageLayout: The same Pydantic object with `text` and `confidence` fields populated.
    """
    all_bboxes = []
    line_references = []

    for column in layout.columns:
        for line in column.lines:
            all_bboxes.append(line.bbox.coordinates)
            line_references.append(line)

    if not all_bboxes:
        logger.warning(
            f"Page {layout.page_number} has no text boxes to process. Passing empty layout."
        )
        return layout

    logger.debug(
        f"Page {layout.page_number}: Running batched text recognition on {len(all_bboxes)} lines..."
    )

    # Surya v0.17+ RecognitionPredictor handles detection internally
    recognition_results = rec_predictor([image], det_predictor=det_predictor)[0]

    recognized_lines = list(recognition_results.text_lines)
    if len(recognized_lines) != len(line_references):
        logger.warning(
            f"Page {layout.page_number}: line count mismatch "
            f"(layout={len(line_references)}, recognized={len(recognized_lines)}). "
            "Mapping by geometric fallback."
        )

    _apply_recognition_mapping(layout_lines=line_references, recognized_lines=recognized_lines)

    logger.info(f"Page {layout.page_number}: Text recognition successfully completed.")

    return layout


def _apply_recognition_mapping(layout_lines: list[TextLine], recognized_lines: list) -> None:
    """Map recognized lines to pre-computed layout lines using geometric affinity."""
    assigned_layout_indexes: set[int] = set()

    for rec_line in recognized_lines:
        rec_bbox = getattr(rec_line, "bbox", None)
        if rec_bbox and len(rec_bbox) == 4:
            target_index = _best_layout_index(
                rec_bbox=rec_bbox, layout_lines=layout_lines, used=assigned_layout_indexes
            )
        else:
            target_index = _next_unassigned_index(len(layout_lines), assigned_layout_indexes)

        if target_index is None:
            break

        target_line = layout_lines[target_index]
        target_line.text = rec_line.text
        target_line.confidence = rec_line.confidence
        assigned_layout_indexes.add(target_index)


def _best_layout_index(
    rec_bbox: list[float], layout_lines: list[TextLine], used: set[int]
) -> int | None:
    rec_center_x = (rec_bbox[0] + rec_bbox[2]) / 2
    rec_center_y = (rec_bbox[1] + rec_bbox[3]) / 2

    best_index = None
    best_distance = float("inf")
    for index, candidate in enumerate(layout_lines):
        if index in used:
            continue
        cand_bbox = candidate.bbox.coordinates
        cand_center_x = (cand_bbox[0] + cand_bbox[2]) / 2
        cand_center_y = (cand_bbox[1] + cand_bbox[3]) / 2
        distance = ((cand_center_x - rec_center_x) ** 2) + ((cand_center_y - rec_center_y) ** 2)
        if distance < best_distance:
            best_distance = distance
            best_index = index

    return best_index


def _next_unassigned_index(total: int, used: set[int]) -> int | None:
    for index in range(total):
        if index not in used:
            return index
    return None
